#include "ColliderUtil_HLSL.cginc"
#include "VectorUtil_HLSL.cginc"

#pragma kernel HWA_SolveCollision;
#pragma kernel HWA_UpdateBufferVelocity;

struct RBCollision
{
    float3 penetration;
    
    int velId_a;
    int velId_b;
    
    float3 velAdd_a;
    float3 angVelAdd_a;
    float3 velAdd_b;
    float3 angVelAdd_b;
    
    float inverseMass_a;
    float3 inverseInertiaWs_a;
    float inverseMass_b;
    float3 inverseInertiaWs_b;
    
    float friction;
};

struct RBCollisionJacobian
{
    float3 va;
    float3 wa;
    float3 vb;
    float3 wb;
    int type;
    float totalLambda;
    float totalLambdaInFrame;
    float effectiveMass;
    float bias;
};

void ResolveJacobian(RBCollision rbc, inout RBCollisionJacobian j, float3 vel_a, float3 angVel_a, float3 vel_b, float3 angVel_b, inout float3 velAdd_a, inout float3 angVelAdd_a, inout float3 velAdd_b, inout float3 angVelAdd_b, float nTotalLambda)
{
    float jv = 0;
    jv += dot(j.va, vel_a + velAdd_a);
    jv += dot(j.wa, angVel_a + angVelAdd_a);
    jv += dot(j.vb, vel_b + velAdd_b);
    jv += dot(j.wb, angVel_b + angVelAdd_b);
    
    float lambda = j.effectiveMass * (-(jv + j.bias));
    
    float oldTotalLambda = j.totalLambda;
    
    if (j.type == 0)
    {
        j.totalLambda = max(0, j.totalLambda + lambda);
    }
    else
    {
        float maxFriction = rbc.friction * nTotalLambda;
        j.totalLambda = clamp(j.totalLambda + lambda, -maxFriction, maxFriction);
    }
    
    lambda = j.totalLambda - oldTotalLambda;
    
    velAdd_a += rbc.inverseMass_a * j.va * lambda;
    angVelAdd_a += Scale(rbc.inverseInertiaWs_a, j.wa) * lambda;
    velAdd_b += rbc.inverseMass_b * j.vb * lambda;
    angVelAdd_b += Scale(rbc.inverseInertiaWs_b, j.wb) * lambda;
    
    j.totalLambdaInFrame = 0;
}

int sc_threads_w;
int sc_threadGroups_w;

RWStructuredBuffer<RBCollision> sc_cols;
RWStructuredBuffer<RBCollisionJacobian> sc_jacobians;
RWStructuredBuffer<float3> sc_vels;

int sc_cols_count;

[numthreads(32,32,1)]
void HWA_SolveCollision(uint3 id : SV_DispatchThreadID)
{
    int colId = id.x + id.y * sc_threads_w;
    
    if (colId < sc_cols_count)
    {
        RBCollision col = sc_cols[colId];
        
        int va = col.velId_a;
        int vb = col.velId_b;
        
        if (va != vb)
        {
            RBCollisionJacobian jN = sc_jacobians[colId * 3];
            RBCollisionJacobian jT = sc_jacobians[colId * 3 + 1];
            RBCollisionJacobian jB = sc_jacobians[colId * 3 + 2];
        
            float3 velAdd_a = 0;
            float3 angVelAdd_a = 0;
            float3 velAdd_b = 0;
            float3 angVelAdd_b = 0;
    
            float3 vel_a = (va != -1) ? sc_vels[va * 2] : 0;
            float3 angVel_a = (va != -1) ? sc_vels[va * 2 + 1] : 0;
            float3 vel_b = (vb != -1) ? sc_vels[vb * 2] : 0;
            float3 angVel_b = (vb != -1) ? sc_vels[vb * 2 + 1] : 0;
        
            ResolveJacobian(col, jN, vel_a, angVel_a, vel_b, angVel_b, velAdd_a, angVelAdd_a, velAdd_b, angVelAdd_b, 0);
            ResolveJacobian(col, jT, vel_a, angVel_a, vel_b, angVel_b, velAdd_a, angVelAdd_a, velAdd_b, angVelAdd_b, jN.totalLambda);
            ResolveJacobian(col, jB, vel_a, angVel_a, vel_b, angVel_b, velAdd_a, angVelAdd_a, velAdd_b, angVelAdd_b, jN.totalLambda);
    
            sc_jacobians[colId * 3] = jN;
            sc_jacobians[colId * 3 + 1] = jT;
            sc_jacobians[colId * 3 + 2] = jB;
        
            col.velAdd_a = velAdd_a;
            col.angVelAdd_a = angVelAdd_a;
            col.velAdd_b = velAdd_b;
            col.angVelAdd_b = angVelAdd_b;
        
            sc_cols[colId] = col;
        }
    }
}

// MAX GROUPSHARED MEMORY BYTES : 32kB
groupshared float3 vels[1024]; // 4B * 3 * 1k = 12k;
groupshared float3 angVels[1024]; // 4B * 3 * 1k = 12k;

int sc_vels_count;
int sc_cols_group_count;

int sc_vels_offset;
int sc_cols_group_offset;

void CalcSum_vels(uint gtId)
{
    [unroll(10)]
    for (int i = 0; i < 10; i++)
    {
        int t = round(pow(2, i));
        int t2 = t * 2;
        
        if (gtId % t2 == 0)
        {
            vels[gtId] += vels[gtId + t];
            angVels[gtId] += angVels[gtId + t];
        }
        
        GroupMemoryBarrierWithGroupSync();
    }
}

// DISPATCH THIS FOR : ceil(cols / 1024.) * ceil(rigidbodies / 1024.)
[numthreads(32, 32, 1)]
void HWA_UpdateBufferVelocity(uint3 idG : SV_GroupID, uint3 idGT : SV_GroupThreadID)
{
    int colId = idGT.x + idGT.y * 32 + sc_cols_group_offset;
    int colIdM = idGT.x + idGT.y * 32;
    int velId = idG.x + idG.y * sc_threadGroups_w + sc_vels_offset;
    int velIdM = idG.x + idG.y * sc_threadGroups_w;
    
    vels[colIdM] = 0;
    angVels[colIdM] = 0;
    
    if (colIdM < sc_cols_group_count && sc_cols[colId].velId_a != sc_cols[colId].velId_b)
    {
        if (sc_cols[colId].velId_a == velId)
        {
            vels[colIdM] = sc_cols[colId].velAdd_a;
            angVels[colIdM] = sc_cols[colId].angVelAdd_a;
        }
        
        if (sc_cols[colId].velId_b == velId)
        {
            vels[colIdM] = sc_cols[colId].velAdd_b;
            angVels[colIdM] = sc_cols[colId].angVelAdd_b;
        }
    }
    
    GroupMemoryBarrierWithGroupSync();
    
    CalcSum_vels(colIdM);
    
    if (colIdM == 0 && sc_cols[colId].velId_a != sc_cols[colId].velId_b)
    {
        sc_vels[velId * 2] += vels[0];
        sc_vels[velId * 2 + 1] += angVels[0];
    }
}